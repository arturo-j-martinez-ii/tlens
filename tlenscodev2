from faster_whisper import WhisperModel
import sounddevice as sd
import numpy as np
import wave
from pydub import AudioSegment
import threading
import uuid
import os
import time

# Initialize empty list called "recording_queue"
recording_queue = []

# Initialize any model of Whisper
def initialize_model(model_size):
    model = WhisperModel(model_size, device="cpu", compute_type="int8")
    return model


# Adds newest wave_filename to end of recording_queue list
def add_to_queue(wave_filename):
    recording_queue.append(wave_filename)


# Processes audio files from queue and transcribes using user-specified Whisper model 
# Then, prints results to terminal
def transcribe_audio(model):
    
    # Runs loop to check for new audio files
    while True:
        # Checks if queue is empty, resets loop if queue is populated
        if not recording_queue:
            time.sleep(0.1)
            continue
        
        # Retrieves the first file in recording_queue
        audio_filename = recording_queue.pop(0)

        # Runs transcription if an audio file is in queue
        try:
        # Transcribes the audio file
            segments, info = model.transcribe(audio_filename, beam_size=5) # Beam size is # of word sequences model goes through, shorten to make faster?

            for segment in segments:
                print("[%.2fs -> %.2fs] %s" % (segment.start, segment.end, segment.text))

        finally:
            #might need to move before the term code
            #deletes original audio file, prints error if it can't
            if os.path.exists(audio_filename):
                os.remove(audio_filename)
                print(f"Deleted WAV file: {audio_filename}")
            else:
                print(f"File not found: {audio_filename}")


# Record audio for the transcription program to process
def record_audio(duration=4, sample_rate=44100, channels=1, dtype='float64'):
    while True:
        filename = str(uuid.uuid4())
        wave_filename = os.path.normpath(filename + ".wav")  # Temporary WAV file
        #mp3_filename = os.path.normpath(filename + ".mp3")    # Output MP3 file (if necessary)

        print("Recording...")
        audio = sd.rec(int(duration * sample_rate), samplerate=sample_rate, channels=channels, dtype=dtype)
        sd.wait()  # Wait until the recording is finished

        try:
            # Save the audio to a WAV file
            with wave.open(wave_filename, 'wb') as wf:
                wf.setnchannels(1)  # Stereo
                wf.setsampwidth(2)  # 2 bytes per sample
                wf.setframerate(sample_rate)
                wf.writeframes((audio * 32767).astype(np.int16).tobytes())  # Convert to int16

            # Add WAV file to recording queue
            add_to_queue(wave_filename)
            
        except Exception as e:
            print(f"Error during recording or conversion: {e}")
            continue



def listen_for_exit():
    input("Press Z to stop...\n")
    keyboard.wait('z')
    stop_event.set()

def cleanup_audio_files():
    for f in os.listdir():
        if f.endswith(".wav"):
            try:
                os.remove(f)
                print(f"Deleted: {f}")
            except Exception as e:
                print(f"Error deleting {f}: {e}")

# Create model
model = initialize_model("tiny.en")

# Create threads
record_thread = threading.Thread(target=record_audio)
transcribe_thread = threading.Thread(target=transcribe_audio, args=(model,))

# Start the threads
record_thread.start()
transcribe_thread.start()

# Wait for the threads to complete
record_thread.join()
transcribe_thread.join()

# Clean up
cleanup_audio_files()
print("Program stopped manually and files cleaned up.")
