from faster_whisper import WhisperModel
import sounddevice as sd
import numpy as np
import wave
from pydub import AudioSegment
import threading
import uuid
import os
import time
import tkinter as tk
from tkinter import scrolledtext
import tkinter.font as tkFont
from queue import Queue
import sys

stop_event = threading.Event()

text_queue = Queue()

# Initialize empty list called "recording_queue"
recording_queue = []

# Initialize any model of Whisper
def initialize_model(model_size):
    model = WhisperModel(model_size, device="cpu", compute_type="int8")
    return model


# Adds newest wave_filename to end of recording_queue list
def add_to_queue(wave_filename):
    recording_queue.append(wave_filename)


# Processes audio files from queue and transcribes using user-specified Whisper model 
# Then, prints results to terminal
def transcribe_audio(model):
    
    # Runs loop
    while not stop_event.is_set():
        # Checks if queue is empty, resets loop if queue is populated
        if not recording_queue:
            time.sleep(0.1)
            continue
        
        # Retrieves the first file in recording_queue
        audio_filename = recording_queue.pop(0)

        # Runs transcription if an audio file is in queue
        try:
        # Transcribes the audio file
            segments, info = model.transcribe(audio_filename, beam_size=5) # Beam size is # of word sequences model goes through, shorten to make faster?

            for segment in segments:
                #message = "%s\n\n" % (segment.start, segment.end, segment.text)
                message = f"{segment.text.strip()}\n\n"
                text_queue.put(message)

        finally:
            #might need to move before the term code
            #deletes original audio file, prints error if it can't
            if os.path.exists(audio_filename):
                os.remove(audio_filename)
                print(f"Deleted WAV file: {audio_filename}")
            else:
                print(f"File not found: {audio_filename}")


# Record audio for the transcription program to process
def record_audio(duration=4, sample_rate=44100, channels=1, dtype='float64'):
    while not stop_event.is_set():
        filename = str(uuid.uuid4())
        wave_filename = os.path.normpath(filename + ".wav")  # Temporary WAV file

        print("Recording...")
        audio = sd.rec(int(duration * sample_rate), samplerate=sample_rate, channels=channels, dtype=dtype)
        sd.wait()  # Wait until the recording is finished

        try:
            # Save the audio to a WAV file
            with wave.open(wave_filename, 'wb') as wf:
                wf.setnchannels(1)  # Stereo
                wf.setsampwidth(2)  # 2 bytes per sample
                wf.setframerate(sample_rate)
                wf.writeframes((audio * 32767).astype(np.int16).tobytes())  # Convert to int16

            # Add WAV file to recording queue
            add_to_queue(wave_filename)
            
        except Exception as e:
            print(f"Error during recording or conversion: {e}")
            continue



def listen_for_exit():
    input("Press Esc to stop...\n")
    keyboard.wait('escape')
    stop_event.set()

def cleanup_audio_files():
    for f in os.listdir():
        if f.endswith(".wav"):
            try:
                os.remove(f)
                print(f"Deleted: {f}")
            except Exception as e:
                print(f"Error deleting {f}: {e}")




# Create tkinter window
root = tk.Tk()
root.attributes("-fullscreen", True) # Makes window fullscreen
root.configure(bg='black')

chosen_font = tkFont.Font(family="Helvetica", size=48, weight=tkFont.BOLD)

# Text box for displaying transcriptions
text_display = scrolledtext.ScrolledText(root, wrap=tk.WORD, font=chosen_font, bg='black', fg='white')
text_display.pack(expand=True, fill='both')
text_display.insert(tk.END, "Starting transcription... \n")
text_display.configure(state='disabled') # Make read-only


def update_gui():
    while not text_queue.empty():
        msg = text_queue.get()
        text_display.configure(state='normal')
        text_display.insert(tk.END, msg)
        text_display.see(tk.END)
        text_display.configure(state='disabled')
    root.after(100, update_gui) # Check every 100ms

def exit_fullscreen(event=None):
    root.destroy()
    
def exit_program(event=None):
    stop_event.set()
    root.destroy()


root.bind("<Escape>", exit_program)








# Create model
model = initialize_model("tiny.en")

# Create threads
record_thread = threading.Thread(target=record_audio, daemon=True)
transcribe_thread = threading.Thread(target=transcribe_audio, args=(model,))

# Start the threads
record_thread.start()
transcribe_thread.start()

# Start updating the GUI
root.after(100, update_gui)
root.mainloop()

# Wait for the threads to complete
record_thread.join()
transcribe_thread.join()

# Clean up
cleanup_audio_files()
print("Program stopped manually and files cleaned up.")
